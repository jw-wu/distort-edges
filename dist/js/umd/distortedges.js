!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.DistortedShape=t():e.DistortedShape=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var s in n)e.o(n,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:n[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>_});const n=!1,s=3,o="#fa0",i="#4caf50";function a(e,t){n&&(t?console.log(`%c${e}`,`color: ${t}`):console.log(e))}function r(e){return Math.round(e*Math.pow(10,s))/Math.pow(10,s)}function l(e){return e*(180/Math.PI)}function d(e){return e*(Math.PI/180)}function c(e){let t=0;if(void 0===e.adjacentSide||isNaN(e.adjacentSide)||(++t,e.adjacentSide=Math.abs(e.adjacentSide)),void 0===e.oppositeSide||isNaN(e.oppositeSide)||(++t,e.oppositeSide=Math.abs(e.oppositeSide)),void 0===e.angle||isNaN(e.angle)||(++t,e.angle=Math.abs(e.angle)),t<2)console.log("%cNot enough values to calculate the hypotenuse of the triangle.","color: #f30;");else{if("number"==typeof e.adjacentSide&&"number"==typeof e.oppositeSide)return Math.sqrt(e.adjacentSide*e.adjacentSide+e.oppositeSide*e.oppositeSide)||0;if("number"==typeof e.oppositeSide&&"number"==typeof e.angle)return Math.abs(e.oppositeSide/Math.sin(d(e.angle)));if("number"==typeof e.adjacentSide&&"number"==typeof e.angle)return Math.abs(e.adjacentSide/Math.cos(d(e.angle)))}return null}function h(e){let t=0;if(void 0===e.hypotenuse||isNaN(e.hypotenuse)||(++t,e.hypotenuse=Math.abs(e.hypotenuse)),void 0===e.adjacentSide||isNaN(e.adjacentSide)||(++t,e.adjacentSide=Math.abs(e.adjacentSide)),void 0===e.angle||isNaN(e.angle)||(++t,e.angle=Math.abs(e.angle)),t<2)console.log("%cNot enough values to calculate the opoosite side of the triangle.","color: #f30;");else{if(void 0!==e.hypotenuse&&void 0!==e.adjacentSide)return Math.sqrt(e.hypotenuse*e.hypotenuse+e.adjacentSide*e.adjacentSide);if(void 0!==e.hypotenuse&&void 0!==e.angle)return Math.abs(Math.sin(d(e.angle))*e.hypotenuse);if(void 0!==e.adjacentSide&&void 0!==e.angle)return Math.abs(Math.tan(d(e.angle))*e.adjacentSide)}return null}const u=3;function m(e){return Math.round(e*Math.pow(10,u))/Math.pow(10,u)}function g(e,t){return{x:t.x+(t.x-e.x),y:t.y+(t.y-e.y)}}function f(e,t,n){return"before"===n?{x:e.x-t.x,y:e.y-t.y}:{x:e.x+t.x,y:e.y+t.y}}function p(e,t){const n=c({adjacentSide:Math.abs(e.x-t.x),oppositeSide:Math.abs(e.y-t.y)});return null!=n?m(n):NaN}function y(e,t,n,s){return 0===n.length?x(e,t,s):1===n.length?b(e,n[0],t,s):2===n.length?N(e,n[0],n[1],t,s):(console.error('More than 2 handles received for getPointOnPath. Parameter "handles" should not contain more than 2 Vectors.'),null)}function x(e,t,n){const s=e.x+n*(t.x-e.x),o=e.y+n*(t.y-e.y);return{x:m(s),y:m(o)}}function b(e,t,n,s){return{x:(1-s)*(1-s)*e.x+2*(1-s)*s*t.x+s*s*n.x,y:(1-s)*(1-s)*e.y+2*(1-s)*s*t.y+s*s*n.y}}function N(e,t,n,s,o){return{x:(1-o)*(1-o)*(1-o)*e.x+3*(1-o)*(1-o)*o*t.x+3*(1-o)*o*o*n.x+o*o*o*s.x,y:(1-o)*(1-o)*(1-o)*e.y+3*(1-o)*(1-o)*o*t.y+3*(1-o)*o*o*n.y+o*o*o*s.y}}function C(e,t){const n=0-e.x,s=0-e.y,o={x:t.x+n,y:t.y+s};return m(l(Math.atan2(-o.y,o.x)))}function S(e){const t=Math.atan2(e.line1.start.y-e.line1.end.y,e.line1.start.x-e.line1.end.x),n=Math.atan2(e.line2.end.y-e.line2.start.y,e.line2.end.x-e.line2.start.x);return Math.abs(l(n-t))}function v(e,t){const n=e*(Math.PI/180),s=t*Math.cos(n),o=t*Math.sin(n);return{x:m(s),y:m(-o)}}function M(e,t){let n="clockwise"===t?e-90:e+90;return n>360?n-=360:n<0&&(n+=360),m(n)}function $(e,t,n,s){if(0===n)return t;{const o=v(M(e,s),n);return{x:t.x+o.x,y:t.y+o.y}}}function w(e,t,n){a("Starting distortedges-startingpoint.create()",o);const s=e.getLastCommandOnPath(t,!1),l=e.getNextCommand(t);if(l){const o=e.getPathSegmentByCommand(s),d=e.settings.distanceApart?e.settings.distanceApart:o.increments[o.increments.length-1]*o.pathLength,c=y(s.origin,s.coords,s.handles,r((o.pathLength-d)/o.pathLength)),h=e.getPathSegmentByCommand(l),u=e.settings.distanceApart?e.settings.distanceApart:h.increments[0]*o.pathLength,m=y(l.origin,l.coords,l.handles,r(u/h.pathLength));if(c&&m){let s,o={coords:{x:NaN,y:NaN},handleAngle:NaN},r=0;if(e.settings.keepWithinOriginalSize||(r=n.variableDistortionDistance?Math.random()*n.maximumDistortionDistance:n.maximumDistortionDistance),0===r)s=t.origin;else{const e=v(M(C(c,m),"clockwise"===t.winding?"counter-clockwise":"clockwise"),r);s={x:t.origin.x+e.x,y:t.origin.y+e.y}}let l=`M ${s.x} ${s.y}`;const d=C(c,m);e.getPathSegmentByCommand(t).subpoints=[{coords:s,slope:d,segmentDistance:0}];const h=e.getLastCommandOnPath(t);return e.getPathSegmentByCommand(h).subpoints=[{coords:s,slope:-d,segmentDistance:0}],o.coords=s,o.handleAngle=d,a("Completed distortedges-startingpoint.create(). Result type: "+typeof l,i),{path:l,previousSubpoint:o}}}return a("Completed distortedges-startingpoint.create(). Result type: null","#f30"),null}function D(e,t,n,s,l){a("Starting distortedges-uniformdistance.create()",o);let d="",c=e.getPathSegmentByCommand(t),u={half:{offset:NaN,rotation:"counter-clockwise",coords:{x:NaN,y:NaN},slope1:NaN,slope2:NaN,handleDistance1:{x:NaN,y:NaN},handleDistance2:{x:NaN,y:NaN},handle1:{x:NaN,y:NaN},handle2:{x:NaN,y:NaN}},full:{offset:NaN,rotation:"counter-clockwise",coords:{x:NaN,y:NaN},slope1:NaN,slope2:NaN,handleDistance1:{x:NaN,y:NaN},handleDistance2:{x:NaN,y:NaN},handle1:{x:NaN,y:NaN},handle2:{x:NaN,y:NaN}}};const m="clockwise"===t.winding?"clockwise":"counter-clockwise",g="clockwise"===t.winding?"counter-clockwise":"clockwise",y=e.getPreviousCommand(t),b=e.getNextCommand(t),N=c.subSegments-1;for(let o=0;o<c.subSegments;++o){const i=0!==n.handleDistancePeak||0!==n.handleDistanceTrough,a="Z"===(null==b?void 0:b.type)&&o===N,M=!n.forceDistortion&&1===c.subSegments;if(n.variableDistortionDistance)if(e.settings.keepWithinOriginalSize){const e=M?0:2*n.maximumDistortionDistance;u.half.offset=Math.random()*e,u.full.offset=Math.random()*e,u.half.rotation=m,u.full.rotation=m}else{const e=M?0:n.maximumDistortionDistance;u.half.offset=Math.random()*e,u.full.offset=Math.random()*e;let t=Math.ceil(2*Math.random());u.half.rotation=1===t?m:g,t=Math.ceil(2*Math.random()),u.half.rotation=1===t?m:g}else e.settings.keepWithinOriginalSize?(u.half.offset=M?0:n.maximumDistortionDistance,u.full.offset=0):(u.half.offset=0,u.full.offset=M?0:n.maximumDistortionDistance),u.half.rotation=m,u.full.rotation=g;const w=c.subpoints[o],D=0===o?t.origin:c.subpoints[o-1].coords,P=x(D,w.coords,.5);let k=C(D,w.coords);if("L"===t.type&&(0===o?k+=22.5:o===N&&(k-=22.5)),u.half.coords=$(k,P,u.half.offset,u.half.rotation),e.settings.keepWithinOriginalSize)u.full.coords=w.coords;else if(a){const n=e.getFirstCommandOnPath(t),s=e.getPathSegmentByCommand(n);u.full.coords=s.subpoints[0].coords}else u.full.coords=$(w.slope,w.coords,u.full.offset,u.full.rotation);if(i){if(y&&0===o){const t=e.getPathSegmentByCommand(y),n=t.subpoints.length-1;u.half.slope1=t.subpoints[n].slope}else u.half.slope1=l.handleAngle;u.half.slope2=C(D,w.coords),u.full.slope1=u.half.slope2,u.full.slope2=w.slope;const t=n.handleDistancePeak,s=n.handleDistanceTrough;let i=S({line1:{start:l.coords,end:u.half.coords},line2:{start:u.half.coords,end:u.full.coords}})/2;i>90&&(i=180-i);const a=h({hypotenuse:p(l.coords,u.half.coords),angle:i});let r=null!=a?a:.5*w.segmentDistance;r=Number(r.toFixed(2));const d=h({hypotenuse:p(u.half.coords,u.full.coords),angle:i});let c=null!=d?d:.5*w.segmentDistance;c=Number(c.toFixed(2)),u.half.handleDistance1=v(u.half.slope1,r*t),u.half.handle1=f(l.coords,u.half.handleDistance1,"after"),u.half.handleDistance2=v(u.half.slope2,r*s),u.half.handle2=f(u.half.coords,u.half.handleDistance2,"before"),u.full.handleDistance1=v(u.full.slope1,c*s),u.full.handle1=f(u.half.coords,u.full.handleDistance1,"after"),u.full.handleDistance2=v(u.full.slope2,c*t),u.full.handle2=f(u.full.coords,u.full.handleDistance2,"before")}s.discern(u.half.coords),s.discern(u.full.coords),l.coords=u.full.coords,i&&(l.handleAngle=u.full.slope2),d=i?[d,"C",r(u.half.handle1.x),r(u.half.handle1.y),r(u.half.handle2.x),r(u.half.handle2.y),r(u.half.coords.x),r(u.half.coords.y),"C",r(u.full.handle1.x),r(u.full.handle1.y),r(u.full.handle2.x),r(u.full.handle2.y),r(u.full.coords.x),r(u.full.coords.y)].join(" "):[d,"L",r(u.half.coords.x),r(u.half.coords.y),"L",r(u.full.coords.x),r(u.full.coords.y)].join(" ")}return a("Completed distortedges-variabledistance.distort(). Result type: "+typeof d,i),{path:d.trim(),previousSubpoint:l}}const P="color: #C191FF;",k="color: #f30;";class L{constructor(e){var t,n,s;this.commands=[],this.nsew=[0,0,0,0];const o={firstCoords:{x:0,y:0},previousCoords:{x:0,y:0},currentCoords:{x:0,y:0},area:0,vectorCommands:[]};let i=e.split(" ");for(let e of i)if(/[MLQCZ]/i.test(e)){let t={type:e,handles:[],coords:{x:NaN,y:NaN},origin:{x:NaN,y:NaN},winding:"clockwise"};if(this.commands.push(t),"Z"===e){const e=this.getPreviousCommand(t),n=this.getFirstCommandOnPath(t);if(e&&(e.coords.x!==n.coords.x||e.coords.y!==n.coords.y)){let n=this.getFirstCommandOnPath(t);this.commands.splice(this.commands.length-1,0,{type:"L",handles:[],coords:n.coords,origin:e.coords,winding:o.area>0?"counter-clockwise":"clockwise"})}}if("Z"!==e)o.vectorCommands.push(t),o.previousCoords=Object.assign({},o.currentCoords);else{o.area+=this._getWindingArea(o.currentCoords,o.firstCoords);const e=o.area>0?"counter-clockwise":"clockwise";for(let t=0;t<o.vectorCommands.length;++t){let n=o.vectorCommands[t];if("Z"===n.type){const t=this.getPreviousCommand(n);n.winding=t?t.winding:e}else n.winding=e}}}else{const i=this.commands[this.commands.length-1],a=Number(e);switch(i.type){case"M":case"L":if(isNaN(i.coords.x))i.coords.x=a,this._setEW(a),"M"===i.type&&(o.firstCoords.x=a),o.currentCoords.x=a;else{i.coords.y=a;const e=null!==(t=this.getPreviousCommand(i))&&void 0!==t?t:{coords:{x:0,y:0}};i.origin="M"===i.type?i.coords:e.coords,this._setNS(a),"M"===i.type&&(o.firstCoords.y=a),o.currentCoords.y=a,"M"!==i.type&&(o.area+=this._getWindingArea(o.previousCoords,o.currentCoords))}break;case"C":if(0===i.handles.length)i.handles.push({x:a,y:NaN});else if(1===i.handles.length&&isNaN(i.handles[0].y))i.handles[0].y=a;else if(1===i.handles.length)i.handles.push({x:a,y:NaN});else if(2===i.handles.length&&isNaN(i.handles[1].y))i.handles[1].y=a;else if(isNaN(i.coords.x))i.coords.x=a,this._setEW(a),o.currentCoords.x=a;else{i.coords.y=a;const e=null!==(n=this.getPreviousCommand(i))&&void 0!==n?n:{coords:{x:0,y:0}};i.origin=e.coords,this._setNS(a),o.currentCoords.y=a,o.area+=this._getWindingArea(o.previousCoords,o.currentCoords)}break;case"Q":if(0===i.handles.length)i.handles.push({x:a,y:NaN});else if(1===i.handles.length)i.handles[0].y=a;else if(isNaN(i.coords.x))i.coords.x=a,this._setEW(a),o.currentCoords.x=a;else{i.coords.y=a;const e=null!==(s=this.getPreviousCommand(i))&&void 0!==s?s:{coords:{x:0,y:0}};i.origin=e.coords,this._setNS(a),o.currentCoords.y=a,o.area+=this._getWindingArea(o.previousCoords,o.currentCoords)}}}}_setNS(e){e<this.nsew[0]?this.nsew[0]=e:e>this.nsew[1]&&(this.nsew[1]=e)}_setEW(e){e<this.nsew[3]?this.nsew[3]=e:e>this.nsew[2]&&(this.nsew[2]=e)}_getWindingArea(e,t){return(t.x-e.x)*(t.y+t.y)}size(){return this.commands.length}getCommandIndex(e){return this.commands.indexOf(e)}getCommand(e){return this.commands[e]}getFirstCommandOnPath(e,t){t=null==t||t;const n=this.getCommandIndex(e);let s=e;if(n>0){for(let e=n-1;e>=0;--e)if(0===e)s=this.getCommand(0);else if("Z"===this.getCommand(e).type){let n=e+1;if(t)s=this.getCommand(n);else{for(;"M"===this.getCommand(n).type;)++n;s=this.getCommand(n)}break}}else 0===n?s=e:console.error("Vector command not found in model.");return s}getLastCommandOnPath(e,t){t=null==t||t;const n=this.size(),s=this.getCommandIndex(e);let o=e;if(s>=0){for(let e=s;e<n;++e)if(o=this.getCommand(e),"Z"===this.getCommand(e).type){t||(o=this.getCommand(e-1));break}}else console.error("Vector command not found in model.");return o}getPreviousCommand(e){const t=this.commands.indexOf(e);return 0===t?(console.log("%cLast command in library retrieved as current command is the first.",P),this.commands[this.commands.length-1]):t>0?this.commands[t-1]:(console.log(`%cNo such command found. Command requested: ${JSON.stringify(e)}`,k),null)}getNextCommand(e){const t=this.commands.indexOf(e);return t===this.size()-1?(console.log("%cFirst command of library retrieved as current command is the last.",P),this.commands[0]):t>-1?this.commands[t+1]:(console.log(`%cNo such command found. Command requested: ${JSON.stringify(e)}`,k),null)}saveCoords(e,t){const n=this.getCommandIndex(e);this.getCommand(n).coords={x:t.x,y:t.y}}saveHandle(e,t){const n=this.getCommandIndex(e);this.getCommand(n).handles=t}getBoundingBox(){return{width:this.nsew[2]-this.nsew[3],height:this.nsew[1]-this.nsew[0]}}}class A extends L{constructor(e,t){super(e),this.pathSegments=[],this.perimeter=0,this.settings=t;for(let e of this.commands){const n=this._getPathSegment(e,t);n&&this.pathSegments.push(n),this._generateSubpoints(e,this.getLastPathSegment()),this.perimeter+=this.getLastPathSegment().pathLength}}_getPathSegment(e,t){var n,s;if("M"===e.type||"Z"===e.type)return{pathLength:0,subSegments:0,increments:[],subpoints:[]};if("L"===e.type||"Q"===e.type||"C"===e.type){let o=this.getPreviousCommand(e),i={pathLength:0,subSegments:0,increments:[],subpoints:[]};if(o){if("Z"===o.type&&(o=this.getFirstCommandOnPath(o)),"L"===e.type?i.pathLength=p(o.coords,e.coords):"Q"===e.type?i.pathLength=function(e,t,n){let s=0;for(let o=1;o<30;++o){const i=b(e,t,n,o/30),a=b(e,t,n,(o+1)/30),r=c({adjacentSide:Math.abs(i.x-a.x),oppositeSide:Math.abs(i.y-a.y)});if("number"!=typeof r){console.error("Calculated segment length for quadratic path length returned as null.");break}s+=m(r)}return m(s)}(o.coords,e.handles[0],e.coords):"C"===e.type&&(i.pathLength=function(e,t,n,s){let o=0;for(let i=1;i<30;++i){const a=N(e,t,n,s,i/30),r=N(e,t,n,s,(i+1)/30),l=c({adjacentSide:Math.abs(a.x-r.x),oppositeSide:Math.abs(a.y-r.y)});if("number"!=typeof l){console.error("Calculated segment length for cubic path length returned as null.");break}o+=m(l)}return m(o)}(o.coords,e.handles[0],e.handles[1],e.coords)),t.variableDistanceApart){const e=this._getVariableDistances(i.pathLength,null!==(n=t.minDistanceApart)&&void 0!==n?n:0,null!==(s=t.maxDistanceApart)&&void 0!==s?s:0);i.subSegments=e.length,i.increments=[...e]}else{const n=0!==t.distanceApart&&t.distanceApart?t.distanceApart:.1*i.pathLength,s=this._getUniformDistances(e,i.pathLength,n,t.keepWithinOriginalSize);i.subSegments=s.length,i.increments=[...s]}return i}console.error("Previous command could not be retreived as Vector Command could not be found.")}return null}_generateSubpoints(e,t){let n=0;if("M"===e.type)n=this.getCommandIndex(e),this.getPathSegmentByCommand(e).subpoints.push({coords:e.coords,slope:0,segmentDistance:0});else if("Z"!==e.type){let n=y(e.origin,e.coords,e.handles,t.increments[0]);if(null===n)return void console.error("Current subpoint coords in the Extended Vector Node Model cannot be determined.");{let s=e.origin,o=t.increments[0],i={x:NaN,y:NaN};for(let a=0;a<t.subSegments;++a){const r=t.increments[a]*t.pathLength,l=this.getPreviousCommand(e);if(0===a&&l&&"M"!==l.type&&"Z"!==l.type){const e=this.getPathSegmentByCommand(l);let t=e.subpoints[e.subpoints.length-1];const s=y(l.origin,l.coords,l.handles,1-e.increments[e.increments.length-1]),o=n;s?t.slope=C(s,o):console.error("Starting point of slope cannot be determined.")}a!==t.subSegments-1?(o+=t.increments[a+1],i=y(e.origin,e.coords,e.handles,o),this.getPathSegmentByCommand(e).subpoints.push({coords:n,slope:C(s,i),segmentDistance:r})):this.getPathSegmentByCommand(e).subpoints.push({coords:n,slope:0,segmentDistance:r}),s=n,n=i}}}else{this.getPathSegmentByCommand(e).subpoints.push({coords:{x:NaN,y:NaN},slope:0,segmentDistance:0});const t=this.getPreviousCommand(e);if(t){const e=this.getPathSegmentByCommand(t),s=1-e.increments[e.increments.length-1];let o=e.subpoints[e.subpoints.length-1];const i=this.getCommand(n+1),a=this.getPathSegmentByCommand(i),r=C(y(t.origin,t.coords,t.handles,s),y(i.origin,i.coords,i.handles,a.increments[0]));o.slope=r,this.getPathSegmentByCommand(this.getCommand(n)).subpoints[0].slope=r}}}_getUniformDistances(e,t,n,s){let o=[];if(t<=n)o.push(1);else if(s&&"L"===e.type){const e=2*n/t,s=t-4*n;o.push(e);const i=Math.round(s/n),a=s/i/t;for(let e=0;e<i;++e)o.push(a);o.push(e)}else{const e=Math.round(t/n),s=t/e/t;for(let t=0;t<e;++t)o.push(s)}return o}_getVariableDistances(e,t,n){let s=[],o=e;const i=0===t?.2:t/e,a=0===n?.5:n/e,l=i*e;for(;o>0;){let t=r((d=i,c=a,Math.round(100*(Math.random()*(c-d)+d))/100/2*e));if(o<=l){0===s.length?s.push(1):s[s.length-1]+=r(o/e);break}t>o&&(t=o),s.push(t/e),o-=t}var d,c;return 0===s.length&&s.push(1),s}getLastPathSegment(){return this.pathSegments[this.pathSegments.length-1]}getPathSegmentByCommand(e){return this.pathSegments[this.getCommandIndex(e)]}getPerimeter(){return this.perimeter}}class j{constructor(e,t){this.x=e/2,this.y=t/2,this.n=this.y,this.s=this.y,this.e=this.x,this.w=this.x}discern(e){e.x>this.e?this.e=e.x:e.x<this.w&&(this.w=e.x),e.y>this.s?this.s=e.y:e.y<this.n&&(this.n=e.y)}getCoords(){return{x:this.x-this.w,y:this.y-this.n}}}function O(e){let t=e;if(/d=\"/.test(e)){const n=e.indexOf("d=")+3,s=e.substring(n).indexOf('"')+n;t=e.substring(n,s)}for(;t.search(/([MLHVCSQAZ]\d)|(\d[MLHVCSQAZ])|(Z[MLHVCSQAZ])/i)>-1;){const e=t.search(/([A-Z]\d)|(\d[A-Z])|([A-Z][A-Z])/i)+1;t=[t.substring(0,e),t.substring(e)].join(" ")}return function(e){let t=0,n=0,s="";const o=new RegExp("[MLVHCSQTAZ]","i");let i="",a={x:0,y:0};for(;e.search(o)>-1;){let r=e.search(o),l=e.substring(r,r+1),d=[];switch("Z"!==l&&([d,e]=Z(e)),l){case"M":t=d[0],n=d[1],s=0===s.length?`${l} ${t} ${n}`:`${s} ${l} ${t} ${n}`;break;case"L":t=d[0],n=d[1],s=0===s.length?`M ${t} ${n} ${l} ${t} ${n}`:`${s} ${l} ${t} ${n}`;break;case"H":t=d[0],s=`${s} L ${t} ${n}`;break;case"V":n=d[0],s=`${s} L ${t} ${n}`;break;case"C":t=d[4],n=d[5],s=`${s} C ${d[0]} ${d[1]} ${d[2]} ${d[3]} ${t} ${n}`,a={x:d[2],y:d[3]};break;case"S":if(t=d[2],n=d[3],"C"===i||"S"==i){const e=g(a,{x:t,y:n});s=`${s} C ${e.x} ${e.y} ${d[0]} ${d[1]} ${t} ${n}`}else s=`${s} C ${t} ${n} ${d[0]} ${d[1]} ${t} ${n}`;a={x:d[0],y:d[1]};break;case"Q":t=d[2],n=d[3],s=`${s} Q ${d[0]} ${d[1]} ${t} ${n}`,a={x:d[0],y:d[1]};break;case"T":if(t=d[0],n=d[1],"Q"===i||"T"===i){const e=g(a,{x:t,y:n});s=`${s} Q ${e.x} ${e.y} ${t} ${n}`,a={x:e.x,y:e.y}}else s=`${s} L ${t} ${n}`;break;case"Z":s=`${s} Z`,e=e.search(/Z./)>-1?e.substring(1):""}i=l}return s}(t)}function Z(e){const t=e.search(/[-\d]/),n=e.substring(t).search(/[MLVHCSQTAZ]/i)+t,s=e.substring(t,n).split(" ");let o=[];for(let e of s)isNaN(Number(e))||o.push(Number(Number(e).toFixed(15)));return[o,e.substring(n)]}class _{constructor(e,t,n){var s;"string"!=typeof e&&console.error('Parameter "input" needs to be a string when creating a new DistortedNode object.'),void 0===(s=t).variableDistanceApart?console.error('Parameter "variableDistanceApart" missing.'):"boolean"!=typeof s.variableDistanceApart&&console.error('Parameter "variableDistanceApart" needs to be a boolean.'),s.variableDistanceApart||s.distanceApart?s.variableDistanceApart||"number"==typeof s.distanceApart||console.error('Parameter "distanceApart" needs to be a number.'):console.error('Parameter "distanceApart" missing.'),void 0===s.keepWithinOriginalSize?console.error('Parameter "keepWithinOriginalSize" missing.'):"boolean"!=typeof s.keepWithinOriginalSize&&console.error('Parameter "keepWithinOriginalSize" needs to be a boolean.'),a("Received settings:"),a(t),e=e.includes("<svg")?function(e){let t=[];for(;e.includes("<path");){const n=e.indexOf("<path"),s=e.indexOf(">");t.push(e.substring(n,s+1)),e=e.substring(s+1)}let n="";for(let e of t)n=0===n.length?O(e):[n,O(e)].join(" ");return n}(e):O(e),this.settings=t,this.model=new A(e,t),n&&(this.recipe=n)}getDrawCommands(e){return e?this._distortEdges(e).path:this.recipe?this._distortEdges(this.recipe).path:""}getAll(e){return e?this._distortEdges(e):this.recipe?this._distortEdges(this.recipe):{path:"",center:{x:0,y:0}}}_distortEdges(e){a("Starting distortedges.distortEdges()",o);let t="",n=new j(this.model.getBoundingBox().width,this.model.getBoundingBox().height),s={coords:{x:NaN,y:NaN},handleAngle:NaN};for(let o=0;o<this.model.size();++o){const i=this.model.getCommand(o);switch(i.type){case"M":const o=w(this.model,i,e);o?(t=0===t.length?`${o.path}`:`${t} ${o.path}`,s=o.previousSubpoint):console.error("Starting point could not be created.");break;case"L":case"C":const a=D(this.model,i,e,n,s);t=`${t} ${a.path}`,s=a.previousSubpoint;break;case"Z":t=`${t} Z`}}const r={path:t,center:n.getCoords()};return a("Completed distortedges.distortEdges()",i),a(r),r}}return t.default})()));