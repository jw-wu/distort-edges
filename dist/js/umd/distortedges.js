!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.DistortedShape=t():e.DistortedShape=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var s in n)e.o(n,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:n[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>A});const n=!1,s=3,o="#fa0",a="#4caf50";function i(e,t){n&&(t?console.log(`%c${e}`,`color: ${t}`):console.log(e))}function r(e){return Math.round(e*Math.pow(10,s))/Math.pow(10,s)}const l="color: #C191FF;",d="color: #f30;";class c{constructor(e){var t,n,s;this.commands=[],this.nsew=[0,0,0,0];const o={firstCoords:{x:0,y:0},previousCoords:{x:0,y:0},currentCoords:{x:0,y:0},area:0,vectorCommands:[]};let a=e.split(" ");for(let e of a)if(/[MLQCZ]/i.test(e)){let t={type:e,handles:[],coords:{x:NaN,y:NaN},origin:{x:NaN,y:NaN},winding:"clockwise"};if(this.commands.push(t),"Z"!==e)o.vectorCommands.push(t),o.previousCoords=Object.assign({},o.currentCoords);else{o.area+=this._getWindingArea(o.currentCoords,o.firstCoords);const e=o.area>0?"counter-clockwise":"clockwise";for(let t=0;t<o.vectorCommands.length;++t)o.vectorCommands[t].winding=e}}else{const a=this.commands[this.commands.length-1],i=Number(e);switch(a.type){case"M":case"L":if(isNaN(a.coords.x))a.coords.x=i,this._setEW(i),"M"===a.type&&(o.firstCoords.x=i),o.currentCoords.x=i;else{a.coords.y=i;const e=null!==(t=this.getPreviousCommand(a))&&void 0!==t?t:{coords:{x:0,y:0}};a.origin="M"===a.type?a.coords:e.coords,this._setNS(i),"M"===a.type&&(o.firstCoords.y=i),o.currentCoords.y=i,"M"!==a.type&&(o.area+=this._getWindingArea(o.previousCoords,o.currentCoords))}break;case"C":if(0===a.handles.length)a.handles.push({x:i,y:NaN});else if(1===a.handles.length&&isNaN(a.handles[0].y))a.handles[0].y=i;else if(1===a.handles.length)a.handles.push({x:i,y:NaN});else if(2===a.handles.length&&isNaN(a.handles[1].y))a.handles[1].y=i;else if(isNaN(a.coords.x))a.coords.x=i,this._setEW(i),o.currentCoords.x=i;else{a.coords.y=i;const e=null!==(n=this.getPreviousCommand(a))&&void 0!==n?n:{coords:{x:0,y:0}};a.origin=e.coords,this._setNS(i),o.currentCoords.y=i,o.area+=this._getWindingArea(o.previousCoords,o.currentCoords)}break;case"Q":if(0===a.handles.length)a.handles.push({x:i,y:NaN});else if(1===a.handles.length)a.handles[0].y=i;else if(isNaN(a.coords.x))a.coords.x=i,this._setEW(i),o.currentCoords.x=i;else{a.coords.y=i;const e=null!==(s=this.getPreviousCommand(a))&&void 0!==s?s:{coords:{x:0,y:0}};a.origin=e.coords,this._setNS(i),o.currentCoords.y=i,o.area+=this._getWindingArea(o.previousCoords,o.currentCoords)}break;case"Z":const e=this.getPreviousCommand(a);if(e&&e.coords!==this.getCommand(0).coords){let t=this.getCommand(0);this.commands.push({type:"L",handles:[],coords:{x:t.coords.x,y:t.coords.y},origin:e.coords,winding:o.area>0?"counter-clockwise":"clockwise"})}}}}_setNS(e){e<this.nsew[0]?this.nsew[0]=e:e>this.nsew[1]&&(this.nsew[1]=e)}_setEW(e){e<this.nsew[3]?this.nsew[3]=e:e>this.nsew[2]&&(this.nsew[2]=e)}_getWindingArea(e,t){return(t.x-e.x)*(t.y+t.y)}size(){return this.commands.length}getCommandIndex(e){return this.commands.indexOf(e)}getCommand(e){return this.commands[e]}getFirstCommandOnPath(e,t){t=null==t||t;const n=this.getCommandIndex(e);let s=e;if(n>0){for(let e=n-1;e>=0;--e)if(0===e)s=this.getCommand(0);else if("Z"===this.getCommand(e).type){let n=e+1;if(t)s=this.getCommand(n);else{for(;"M"===this.getCommand(n).type;)++n;s=this.getCommand(n)}break}}else 0===n?s=e:console.error("Vector command not found in model.");return s}getLastCommandOnPath(e,t){t=null==t||t;const n=this.size(),s=this.getCommandIndex(e);let o=e;if(s>=0){for(let e=s;e<n;++e)if(o=this.getCommand(e),"Z"===this.getCommand(e).type){t||(o=this.getCommand(e-1));break}}else console.error("Vector command not found in model.");return o}getPreviousCommand(e){const t=this.commands.indexOf(e);return 0===t?(console.log("%cLast command in library retrieved as current command is the first.",l),this.commands[this.commands.length-1]):t>0?this.commands[t-1]:(console.log(`%cNo such command found. Command requested: ${JSON.stringify(e)}`,d),null)}getNextCommand(e){const t=this.commands.indexOf(e);return t===this.size()-1?(console.log("%cFirst command of library retrieved as current command is the last.",l),this.commands[0]):t>-1?this.commands[t+1]:(console.log(`%cNo such command found. Command requested: ${JSON.stringify(e)}`,d),null)}saveCoords(e,t){const n=this.getCommandIndex(e);this.getCommand(n).coords={x:t.x,y:t.y}}saveHandle(e,t){const n=this.getCommandIndex(e);this.getCommand(n).handles=t}getBoundingBox(){return{width:this.nsew[2]-this.nsew[3],height:this.nsew[1]-this.nsew[0]}}}function h(e){return e*(Math.PI/180)}function m(e){let t=0;if(void 0===e.adjacentSide||isNaN(e.adjacentSide)||(++t,e.adjacentSide=Math.abs(e.adjacentSide)),void 0===e.oppositeSide||isNaN(e.oppositeSide)||(++t,e.oppositeSide=Math.abs(e.oppositeSide)),void 0===e.angle||isNaN(e.angle)||(++t,e.angle=Math.abs(e.angle)),t<2)console.log("%cNot enough values to calculate the hypotenuse of the triangle.","color: #f30;");else{if("number"==typeof e.adjacentSide&&"number"==typeof e.oppositeSide)return Math.sqrt(e.adjacentSide*e.adjacentSide+e.oppositeSide*e.oppositeSide)||0;if("number"==typeof e.oppositeSide&&"number"==typeof e.angle)return Math.abs(e.oppositeSide/Math.sin(h(e.angle)));if("number"==typeof e.adjacentSide&&"number"==typeof e.angle)return Math.abs(e.adjacentSide/Math.cos(h(e.angle)))}return null}const u=3;function g(e){return Math.round(e*Math.pow(10,u))/Math.pow(10,u)}function f(e,t){return{x:t.x+(t.x-e.x),y:t.y+(t.y-e.y)}}function p(e,t,n){return"before"===n?{x:e.x-t.x,y:e.y-t.y}:{x:e.x+t.x,y:e.y+t.y}}function y(e,t,n,s){return 0===n.length?x(e,t,s):1===n.length?b(e,n[0],t,s):2===n.length?N(e,n[0],n[1],t,s):(console.error('More than 2 handles received for getPointOnPath. Parameter "handles" should not contain more than 2 Vectors.'),null)}function x(e,t,n){const s=e.x+n*(t.x-e.x),o=e.y+n*(t.y-e.y);return{x:g(s),y:g(o)}}function b(e,t,n,s){const o={handle1:x(e,t,s),handle2:x(t,n,s)};return x(o.handle1,o.handle2,s)}function N(e,t,n,s,o){const a={handle1:x(e,t,o),middle:x(t,n,o),handle2:x(n,s,o)},i={handle1:x(a.handle1,a.middle,o),handle2:x(a.middle,a.handle2,o)};return x(i.handle1,i.handle2,o)}function C(e,t){const n=0-e.x,s=0-e.y,o={x:t.x+n,y:t.y+s};return g(Math.atan2(-o.y,o.x)*(180/Math.PI))}function S(e,t){const n=e*(Math.PI/180),s=t*Math.cos(n),o=t*Math.sin(n);return{x:g(s),y:g(-o)}}function D(e,t){let n="clockwise"===t?e-90:e+90;return n>360?n-=360:n<0&&(n+=360),g(n)}function $(e,t,n,s){if(0===n)return t;{const o=S(D(e,s),n);return{x:t.x+o.x,y:t.y+o.y}}}class v extends c{constructor(e,t){super(e),this.pathSegments=[],this.perimeter=0;for(let e of this.commands){const n=this._getPathSegment(e,t);n&&this.pathSegments.push(n),this._generateSubpoints(e,this.getLastPathSegment()),this.perimeter+=this.getLastPathSegment().pathLength}}_getPathSegment(e,t){var n,s;if("M"===e.type||"Z"===e.type)return{pathLength:0,subSegments:0,increments:[],subpoints:[]};if("L"===e.type||"Q"===e.type||"C"===e.type){const o=this.getPreviousCommand(e);let a={pathLength:0,subSegments:0,increments:[],subpoints:[]};if(o){if("L"===e.type?a.pathLength=function(e,t){const n=m({adjacentSide:Math.abs(e.x-t.x),oppositeSide:Math.abs(e.y-t.y)});return null!=n?g(n):NaN}(o.coords,e.coords):"Q"===e.type?a.pathLength=function(e,t,n){let s=0;for(let o=1;o<30;++o){const a=b(e,t,n,o/30),i=b(e,t,n,(o+1)/30),r=m({adjacentSide:Math.abs(a.x-i.x),oppositeSide:Math.abs(a.y-i.y)});if("number"!=typeof r){console.error("Calculated segment length for quadratic path length returned as null.");break}s+=g(r)}return g(s)}(o.coords,e.handles[0],e.coords):"C"===e.type&&(a.pathLength=function(e,t,n,s){let o=0;for(let a=1;a<30;++a){const i=N(e,t,n,s,a/30),r=N(e,t,n,s,(a+1)/30),l=m({adjacentSide:Math.abs(i.x-r.x),oppositeSide:Math.abs(i.y-r.y)});if("number"!=typeof l){console.error("Calculated segment length for cubic path length returned as null.");break}o+=g(l)}return g(o)}(o.coords,e.handles[0],e.handles[1],e.coords)),t.variableDistanceApart){const e=this._getVariableDistances(a.pathLength,null!==(n=t.minDistanceApart)&&void 0!==n?n:0,null!==(s=t.maxDistanceApart)&&void 0!==s?s:0);a.subSegments=e.length,a.increments=[...e]}else{const n=0!==t.distanceApart&&t.distanceApart?t.distanceApart:.1*a.pathLength,s=this._getUniformDistances(e,a.pathLength,null!=n?n:0,t.keepWithinOriginalSize,t.maximumDistortionDistance);a.subSegments=s.length,a.increments=[...s]}return a}console.error("Previous command could not be retreived as Vector Command could not be found.")}return null}_generateSubpoints(e,t){let n=0;if("M"===e.type)n=this.getCommandIndex(e),this.getPathSegmentByCommand(e).subpoints.push({coords:e.coords,slope:0,segmentDistance:0});else if("Z"!==e.type){let n=y(e.origin,e.coords,e.handles,t.increments[0]),s=e.origin,o=t.increments[0];for(let a=0;a<t.subSegments;++a){const i=t.increments[a]*t.pathLength;let r={x:NaN,y:NaN};const l=this.getPreviousCommand(e);if(0===a&&l&&"M"!==l.type&&"Z"!==l.type){const e=this.getPathSegmentByCommand(l);let t=e.subpoints[e.subpoints.length-1];const s=y(l.origin,l.coords,l.handles,1-e.increments[e.increments.length-1]),o=n;s?t.slope=C(s,o):console.error("Starting point of slope cannot be determined.")}a!==t.subSegments-1?(o+=t.increments[a+1],r=y(e.origin,e.coords,e.handles,o),this.getPathSegmentByCommand(e).subpoints.push({coords:n,slope:C(s,r),segmentDistance:i})):this.getPathSegmentByCommand(e).subpoints.push({coords:n,slope:0,segmentDistance:i}),s=n,n=r}}else{this.getPathSegmentByCommand(e).subpoints.push({coords:{x:NaN,y:NaN},slope:0,segmentDistance:0});const t=this.getPreviousCommand(e);if(t){const e=this.getPathSegmentByCommand(t),s=1-e.increments[e.increments.length-1];let o=e.subpoints[e.subpoints.length-1];const a=this.getCommand(n+1),i=this.getPathSegmentByCommand(a),r=C(y(t.origin,t.coords,t.handles,s),y(a.origin,a.coords,a.handles,i.increments[0]));o.slope=r,this.getPathSegmentByCommand(this.getCommand(n)).subpoints[0].slope=r}}}_getUniformDistances(e,t,n,s,o){let a=[];if(t<=n)a.push(1);else if(s&&"L"===e.type){const e=2*o/t,s=t-4*o;a.push(e);const i=Math.round(s/n),r=s/i/t;for(let e=0;e<i;++e)a.push(r);a.push(e)}else{const e=Math.round(t/n),s=t/e/t;for(let t=0;t<e;++t)a.push(s)}return a}_getVariableDistances(e,t,n){let s=[],o=e;const a=0===t?.2:t/e,i=0===n?.5:n/e,l=a*e;for(;o>0;){let t=r((d=a,c=i,Math.round(100*(Math.random()*(c-d)+d))/100/2*e));if(o<=l){0===s.length?s.push(1):s[s.length-1]+=r(o/e);break}t>o&&(t=o),s.push(t/e),o-=t}var d,c;return 0===s.length&&s.push(1),s}getLastPathSegment(){return this.pathSegments[this.pathSegments.length-1]}getPathSegmentByCommand(e){return this.pathSegments[this.getCommandIndex(e)]}getPerimeter(){return this.perimeter}}class P{constructor(e,t){this.x=e/2,this.y=t/2,this.n=this.y,this.s=this.y,this.e=this.x,this.w=this.x}discern(e){e.x>this.e?this.e=e.x:e.x<this.w&&(this.w=e.x),e.y>this.s?this.s=e.y:e.y<this.n&&(this.n=e.y)}getCoords(){return{x:this.x-this.w,y:this.y-this.n}}}function M(e,t,n){i("Starting distortedges-startingpoint.create()",o);const s=e.getLastCommandOnPath(t,!1),l=e.getNextCommand(t);if(l){const o=e.getPathSegmentByCommand(s),d=n.distanceApart?n.distanceApart:o.increments[o.increments.length-1]*o.pathLength,c=y(s.origin,s.coords,s.handles,r((o.pathLength-d)/o.pathLength)),h=e.getPathSegmentByCommand(l),m=n.distanceApart?n.distanceApart:h.increments[0]*o.pathLength,u=y(l.origin,l.coords,l.handles,r(m/h.pathLength));if(c&&u){let s,o={coords:{x:NaN,y:NaN},handleAngle:NaN},r=0;if(n.keepWithinOriginalSize||(r=n.variableDistortionDistance?Math.random()*n.maximumDistortionDistance:n.maximumDistortionDistance),0===r)s=t.origin;else{const e=S(D(C(c,u),"counter-clockwise"),r);s={x:t.origin.x+e.x,y:t.origin.y+e.y}}let l=`M ${s.x} ${s.y}`;const d=C(c,u);e.getPathSegmentByCommand(t).subpoints=[{coords:s,slope:d,segmentDistance:0}];const h=e.getLastCommandOnPath(t);return e.getPathSegmentByCommand(h).subpoints=[{coords:s,slope:-d,segmentDistance:0}],o.coords=s,o.handleAngle=d,i("Completed distortedges-startingpoint.create(). Result type: "+typeof l,a),{path:l,previousSubpoint:o}}}return i("Completed distortedges-startingpoint.create(). Result type: null","#f30"),null}function w(e,t,n,s,l){var d,c;i("Starting distortedges-uniformdistance.create()",o);let h="",m=e.getPathSegmentByCommand(t),u={half:{offset:NaN,rotation:"counter-clockwise",coords:{x:NaN,y:NaN},slope1:NaN,slope2:NaN,handleDistance1:{x:NaN,y:NaN},handleDistance2:{x:NaN,y:NaN},handle1:{x:NaN,y:NaN},handle2:{x:NaN,y:NaN}},full:{offset:NaN,rotation:"counter-clockwise",coords:{x:NaN,y:NaN},slope1:NaN,slope2:NaN,handleDistance1:{x:NaN,y:NaN},handleDistance2:{x:NaN,y:NaN},handle1:{x:NaN,y:NaN},handle2:{x:NaN,y:NaN}}};const g="clockwise"===t.winding?"clockwise":"counter-clockwise",f="clockwise"===t.winding?"counter-clockwise":"clockwise",y=e.getPreviousCommand(t),b=e.getNextCommand(t),N=m.subSegments-1;for(let o=0;o<m.subSegments;++o){const a=0!==n.handleDistancePeak||0!==n.handleDistanceTrough,i="Z"===(null==b?void 0:b.type)&&o===N;if(n.variableDistortionDistance)if(n.keepWithinOriginalSize)u.half.offset=Math.random()*(2*n.maximumDistortionDistance),u.full.offset=Math.random()*(2*n.maximumDistortionDistance),u.half.rotation=g,u.full.rotation=g;else{u.half.offset=Math.random()*n.maximumDistortionDistance,u.full.offset=Math.random()*n.maximumDistortionDistance;let e=Math.ceil(2*Math.random());u.half.rotation=1===e?g:f,e=Math.ceil(2*Math.random()),u.half.rotation=1===e?g:f}else n.keepWithinOriginalSize?(u.half.offset=n.maximumDistortionDistance,u.full.offset=0):(u.half.offset=0,u.full.offset=n.maximumDistortionDistance),u.half.rotation=g,u.full.rotation=f;const D=m.subpoints[o],v=0===o?t.origin:m.subpoints[o-1].coords,P=x(v,D.coords,.5);let M=C(v,D.coords);if("L"===t.type&&(0===o?M+=22.5:o===N&&(M-=22.5)),u.half.coords=$(M,P,u.half.offset,u.half.rotation),n.keepWithinOriginalSize)u.full.coords=D.coords;else if(i){const n=e.getFirstCommandOnPath(t),s=e.getPathSegmentByCommand(n);u.full.coords=s.subpoints[0].coords}else u.full.coords=$(D.slope,D.coords,u.full.offset,u.full.rotation);if(a){if(y&&0===o){const t=e.getPathSegmentByCommand(y),n=t.subpoints.length-1;u.half.slope1=t.subpoints[n].slope}else u.half.slope1=l.handleAngle;u.half.slope2=C(v,D.coords),u.full.slope1=u.half.slope2,u.full.slope2=D.slope;const t=null!==(d=n.handleDistancePeak)&&void 0!==d?d:.25,s=null!==(c=n.handleDistanceTrough)&&void 0!==c?c:.25,a=.5*D.segmentDistance,i=l.coords;u.half.handleDistance1=S(u.half.slope1,a*t),u.half.handle1=p(i,u.half.handleDistance1,"after"),u.half.handleDistance2=S(u.half.slope2,a*s),u.half.handle2=p(u.half.coords,u.half.handleDistance2,"before"),u.full.handleDistance1=S(u.full.slope1,a*s),u.full.handle1=p(u.half.coords,u.full.handleDistance1,"after"),u.full.handleDistance2=S(u.full.slope2,a*t),u.full.handle2=p(u.full.coords,u.full.handleDistance2,"before")}s.discern(u.half.coords),s.discern(u.full.coords),l.coords=u.full.coords,a&&(l.handleAngle=u.full.slope2),h=a?[h,"C",r(u.half.handle1.x),r(u.half.handle1.y),r(u.half.handle2.x),r(u.half.handle2.y),r(u.half.coords.x),r(u.half.coords.y),"C",r(u.full.handle1.x),r(u.full.handle1.y),r(u.full.handle2.x),r(u.full.handle2.y),r(u.full.coords.x),r(u.full.coords.y)].join(" "):[h,"L",r(u.half.coords.x),r(u.half.coords.y),"L",r(u.full.coords.x),r(u.full.coords.y)].join(" ")}return i("Completed distortedges-variabledistance.distort(). Result type: "+typeof h,a),{path:h.trim(),previousSubpoint:l}}function k(e){let t=e;if(/d=\"/.test(e)){const n=e.indexOf("d=")+3,s=e.substring(n).indexOf('"')+n;t=e.substring(n,s)}for(;t.search(/([MLHVCSQAZ]\d)|(\d[MLHVCSQAZ])|(Z[MLHVCSQAZ])/i)>-1;){const e=t.search(/([A-Z]\d)|(\d[A-Z])|([A-Z][A-Z])/i)+1;t=[t.substring(0,e),t.substring(e)].join(" ")}return function(e){let t=0,n=0,s="";const o=new RegExp("[MLVHCSQTAZ]","i");let a="",i={x:0,y:0};for(;e.search(o)>-1;){let r=e.search(o),l=e.substring(r,r+1),d=[];switch("Z"!==l&&([d,e]=L(e)),l){case"M":t=d[0],n=d[1],s=0===s.length?`${l} ${t} ${n}`:`${s} ${l} ${t} ${n}`;break;case"L":t=d[0],n=d[1],s=0===s.length?`M ${t} ${n} ${l} ${t} ${n}`:`${s} ${l} ${t} ${n}`;break;case"H":t=d[0],s=`${s} L ${t} ${n}`;break;case"V":n=d[0],s=`${s} L ${t} ${n}`;break;case"C":t=d[4],n=d[5],s=`${s} C ${d[0]} ${d[1]} ${d[2]} ${d[3]} ${t} ${n}`,i={x:d[2],y:d[3]};break;case"S":if(t=d[2],n=d[3],"C"===a||"S"==a){const e=f(i,{x:t,y:n});s=`${s} C ${e.x} ${e.y} ${d[0]} ${d[1]} ${t} ${n}`}else s=`${s} C ${t} ${n} ${d[0]} ${d[1]} ${t} ${n}`;i={x:d[0],y:d[1]};break;case"Q":t=d[2],n=d[3],s=`${s} Q ${d[0]} ${d[1]} ${t} ${n}`,i={x:d[0],y:d[1]};break;case"T":if(t=d[0],n=d[1],"Q"===a||"T"===a){const e=f(i,{x:t,y:n});s=`${s} Q ${e.x} ${e.y} ${t} ${n}`,i={x:e.x,y:e.y}}else s=`${s} L ${t} ${n}`;break;case"Z":s=`${s} Z`,e=e.search(/Z./)>-1?e.substring(1):""}a=l}return s}(t)}function L(e){const t=e.search(/[-\d]/),n=e.substring(t).search(/[MLVHCSQTAZ]/i)+t,s=e.substring(t,n).split(" ");let o=[];for(let e of s)isNaN(Number(e))||o.push(Number(Number(e).toFixed(15)));return[o,e.substring(n)]}class A{constructor(e,t){"string"!=typeof e&&console.error('Parameter "input" needs to be a string when creating a new DistortedNode object.'),function(e){void 0===e.variableDistortionDistance?console.error('Parameter "variableDistortionDistance" missing.'):"boolean"!=typeof e.variableDistortionDistance&&console.error('Parameter "variableDistortionDistance" needs to be a boolean.'),e.maximumDistortionDistance?"number"!=typeof e.maximumDistortionDistance&&console.error('Parameter "maximumDistortionDistance" needs to be a number.'):console.error('Parameter "maximumDistortionDistance" missing.'),void 0===e.variableDistanceApart?console.error('Parameter "variableDistanceApart" missing.'):"boolean"!=typeof e.variableDistanceApart&&console.error('Parameter "variableDistanceApart" needs to be a boolean.'),e.variableDistanceApart||e.distanceApart?e.variableDistanceApart||"number"==typeof e.distanceApart||console.error('Parameter "distanceApart" needs to be a number.'):console.error('Parameter "distanceApart" missing.'),void 0===e.handleDistancePeak?console.error('Parameter "handleDistancePeak" missing.'):"number"!=typeof e.handleDistancePeak&&console.error('Parameter "handleDistancePeak" needs to be a number.'),void 0===e.handleDistanceTrough?console.error('Parameter "handleDistanceTrough" missing.'):"number"!=typeof e.handleDistanceTrough&&console.error('Parameter "handleDistanceTrough" needs to be a number.'),void 0===e.keepWithinOriginalSize?console.error('Parameter "keepWithinOriginalSize" missing.'):"boolean"!=typeof e.keepWithinOriginalSize&&console.error('Parameter "keepWithinOriginalSize" needs to be a boolean.')}(t),i("Received recipe:"),i(t),e=e.includes("<svg")?function(e){let t=[];for(;e.includes("<path");){const n=e.indexOf("<path"),s=e.indexOf(">");t.push(e.substring(n,s+1)),e=e.substring(s+1)}let n="";for(let e of t)n=0===n.length?k(e):[n,k(e)].join(" ");return n}(e):k(e),this.recipe=t,this.model=new v(e,t)}getDrawCommands(e){return e&&(this.recipe=e),this._distortEdges().path}getAll(e){return e&&(this.recipe=e),this._distortEdges()}_distortEdges(){i("Starting distortedges.distortEdges()",o);let e="",t=new P(this.model.getBoundingBox().width,this.model.getBoundingBox().height),n={coords:{x:NaN,y:NaN},handleAngle:NaN};for(let s=0;s<this.model.size();++s){const o=this.model.getCommand(s);switch(o.type){case"M":const s=M(this.model,o,this.recipe);s?(e=0===e.length?`${s.path}`:`${e} ${s.path}`,n=s.previousSubpoint):console.error("Starting point could not be created.");break;case"L":case"C":const a=w(this.model,o,this.recipe,t,n);e=`${e} ${a.path}`,n=a.previousSubpoint;break;case"Z":e=`${e} Z`}}const s={path:e,center:t.getCoords()};return i("Completed distortedges.distortEdges()",a),i(s),s}}return t.default})()));